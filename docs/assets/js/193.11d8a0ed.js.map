{"version":3,"file":"assets/js/193.11d8a0ed.js","mappings":"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","sources":["webpack://pglite_vector_search/../../src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"names":["R","H","v","F","M","y","b","m","x","P","D","S","n","C","O","k","w","f","I","W","j","$","G","T","DIR","FILE","L","B","constructor","e","initialPoolSize","t","maintainedPoolSize","o","debug","i","super","g","Map","lastCheckpoint","checkpointInterval","poolCounter","Set","this","init","r","call","syncToFs","maybeCheckpointState","maintainPool","flush","closeFs","s","values","close","pg","Module","FS","quit","state","pool","length","push","Promise","async","a","Date","now","toString","padStart","h","getFileHandle","create","d","createSyncAccessHandle","set","opp","args","c","pop","get","removeEntry","name","delete","all","_createPoolFileState","_deletePoolFileState","indexOf","splice","checkpointState","TextEncoder","encode","JSON","stringify","truncate","write","at","clear","chmod","_chmodState","mode","fstat","lstat","type","backingFilename","getSize","dev","ino","nlink","uid","gid","rdev","size","blksize","blocks","Math","ceil","atime","lastModified","mtime","ctime","mkdir","_mkdirState","root","Object","prototype","hasOwnProperty","children","recursive","p","join","open","readdir","keys","read","Uint8Array","buffer","rename","_renameState","l","u","rmdir","_rmdirState","add","unlink","_unlinkState","has","utimes","_utimesState","writeFile","Error","startsWith","_createFileNodeState","_setLastModifiedState","WeakMap","WeakSet","E","navigator","storage","getDirectory","dataDir","from","ArrayBuffer","TextDecoder","decode","split","parse","slice","filter","Boolean","map","bind","N","console","warn","error","U","_","getDirectoryHandle","A","code","z"],"sourceRoot":""}